/*
 * generated by Xtext 2.14.0
 */
package com.ufcg.compiladores.serializer;

import com.google.inject.Inject;
import com.ufcg.compiladores.go.Arguments;
import com.ufcg.compiladores.go.CompositeLit;
import com.ufcg.compiladores.go.ConstSpec;
import com.ufcg.compiladores.go.Conversion;
import com.ufcg.compiladores.go.DeferStmt;
import com.ufcg.compiladores.go.ExprCaseClause;
import com.ufcg.compiladores.go.Expression;
import com.ufcg.compiladores.go.ForClause;
import com.ufcg.compiladores.go.FunctionDecl;
import com.ufcg.compiladores.go.FunctionLit;
import com.ufcg.compiladores.go.GoPackage;
import com.ufcg.compiladores.go.IfStmt;
import com.ufcg.compiladores.go.Key;
import com.ufcg.compiladores.go.KeyedElement;
import com.ufcg.compiladores.go.LiteralValue;
import com.ufcg.compiladores.go.MapType;
import com.ufcg.compiladores.go.MethodDecl;
import com.ufcg.compiladores.go.ParameterList;
import com.ufcg.compiladores.go.PrimaryExpr;
import com.ufcg.compiladores.go.PrimaryExprLinha;
import com.ufcg.compiladores.go.RecvStmt;
import com.ufcg.compiladores.go.ReturnStmt;
import com.ufcg.compiladores.go.SelectStmt;
import com.ufcg.compiladores.go.Signature;
import com.ufcg.compiladores.go.Statement;
import com.ufcg.compiladores.go.StructType;
import com.ufcg.compiladores.go.SwitchStmt;
import com.ufcg.compiladores.go.TypeCaseClause;
import com.ufcg.compiladores.go.TypeList;
import com.ufcg.compiladores.go.TypeLit;
import com.ufcg.compiladores.go.VarSpec;
import com.ufcg.compiladores.go.switch_stmt_linha;
import com.ufcg.compiladores.go.topLevelDeclLinha;
import com.ufcg.compiladores.services.GoGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;

@SuppressWarnings("all")
public class GoSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GoGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GoPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GoPackage.ARGUMENTS:
				if (rule == grammarAccess.getArgumentsRule()) {
					sequence_Arguments(context, (Arguments) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprLinhaRule()) {
					sequence_Arguments_PrimaryExprLinha(context, (Arguments) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.COMPOSITE_LIT:
				if (rule == grammarAccess.getOperandRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getCompositeLitRule()) {
					sequence_CompositeLit(context, (CompositeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprRule()
						|| rule == grammarAccess.getTypeSwitchGuardRule()) {
					sequence_CompositeLit_PrimaryExpr(context, (CompositeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprLinhaRule()) {
					sequence_CompositeLit_PrimaryExpr_PrimaryExprLinha(context, (CompositeLit) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.CONST_SPEC:
				sequence_ConstSpec(context, (ConstSpec) semanticObject); 
				return; 
			case GoPackage.CONVERSION:
				if (rule == grammarAccess.getConversionRule()) {
					sequence_Conversion(context, (Conversion) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprRule()
						|| rule == grammarAccess.getTypeSwitchGuardRule()) {
					sequence_Conversion_PrimaryExpr(context, (Conversion) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprLinhaRule()) {
					sequence_Conversion_PrimaryExpr_PrimaryExprLinha(context, (Conversion) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.DEFER_STMT:
				sequence_DeferStmt(context, (DeferStmt) semanticObject); 
				return; 
			case GoPackage.EXPR_CASE_CLAUSE:
				sequence_ExprCaseClause(context, (ExprCaseClause) semanticObject); 
				return; 
			case GoPackage.EXPRESSION:
				if (rule == grammarAccess.getAssignmentRule()) {
					sequence_Assignment_Expression_ExpressionList(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getForStmtRule()
						|| rule == grammarAccess.getForClauseRule()) {
					sequence_Assignment_Expression_ExpressionList_ForClause_SendStmt(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIfStmtRule()) {
					sequence_Assignment_Expression_ExpressionList_IfStmt_SendStmt(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleStmtRule()
						|| rule == grammarAccess.getInitStmtRule()
						|| rule == grammarAccess.getPostStmtRule()) {
					sequence_Assignment_Expression_ExpressionList_SendStmt(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSwitchStmtRule()) {
					sequence_Assignment_Expression_ExpressionList_SendStmt_SwitchStmt(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprLinhaRule()) {
					sequence_CompositeLit_Expression_ExpressionList_LiteralTypeLinha_PrimaryExpr_PrimaryExprLinha(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOperandRule()) {
					sequence_CompositeLit_Expression_LiteralTypeLinha(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getCompositeLitRule()) {
					sequence_CompositeLit_Expression_LiteralTypeLinha(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprRule()
						|| rule == grammarAccess.getTypeSwitchGuardRule()) {
					sequence_CompositeLit_Expression_LiteralTypeLinha_PrimaryExpr(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExprCaseClauseRule()) {
					sequence_ExprCaseClause_Expression_ExpressionList(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getArrayLengthRule()
						|| rule == grammarAccess.getElementRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionStmtRule()
						|| rule == grammarAccess.getChannelRule()
						|| rule == grammarAccess.getIncDecStmtRule()
						|| rule == grammarAccess.getConditionRule()
						|| rule == grammarAccess.getGoStmtRule()
						|| rule == grammarAccess.getRecvExprRule()) {
					sequence_Expression(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionLinhaRule()) {
					sequence_Expression_ExpressionLinha(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSouceFileRule()
						|| rule == grammarAccess.getDeclarationRule()
						|| rule == grammarAccess.getTopLevelDeclRule()
						|| rule == grammarAccess.getExpressionListRule()
						|| rule == grammarAccess.getVarDeclRule()
						|| rule == grammarAccess.getVarSpecRule()
						|| rule == grammarAccess.getShortVarDeclRule()
						|| rule == grammarAccess.getArgumentsRule()
						|| rule == grammarAccess.getExprSwitchCaseRule()
						|| rule == grammarAccess.getRangeClauseRule()) {
					sequence_Expression_ExpressionList(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRecvStmtRule()) {
					sequence_Expression_ExpressionList_RecvStmt(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getCommClauseRule()
						|| rule == grammarAccess.getCommCaseRule()) {
					sequence_Expression_ExpressionList_RecvStmt_SendStmt(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLiteralTypeRule()
						|| rule == grammarAccess.getLiteralTypeLinhaRule()) {
					sequence_Expression_LiteralTypeLinha(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSendStmtRule()) {
					sequence_Expression_SendStmt(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeLitLinhaRule()) {
					sequence_Expression_TypeLitLinha(context, (Expression) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.FOR_CLAUSE:
				sequence_ForClause(context, (ForClause) semanticObject); 
				return; 
			case GoPackage.FUNCTION_DECL:
				sequence_FunctionDecl(context, (FunctionDecl) semanticObject); 
				return; 
			case GoPackage.FUNCTION_LIT:
				if (rule == grammarAccess.getOperandRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getFunctionLitRule()) {
					sequence_FunctionLit(context, (FunctionLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprRule()
						|| rule == grammarAccess.getTypeSwitchGuardRule()) {
					sequence_FunctionLit_PrimaryExpr(context, (FunctionLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprLinhaRule()) {
					sequence_FunctionLit_PrimaryExpr_PrimaryExprLinha(context, (FunctionLit) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.IF_STMT:
				sequence_IfStmt(context, (IfStmt) semanticObject); 
				return; 
			case GoPackage.KEY:
				if (rule == grammarAccess.getElementListRule()) {
					sequence_ElementList_Key_KeyedElement(context, (Key) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKeyRule()) {
					sequence_Key(context, (Key) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKeyedElementRule()) {
					sequence_Key_KeyedElement(context, (Key) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.KEYED_ELEMENT:
				if (rule == grammarAccess.getElementListRule()) {
					sequence_ElementList_KeyedElement(context, (KeyedElement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKeyedElementRule()) {
					sequence_KeyedElement(context, (KeyedElement) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.LITERAL_VALUE:
				if (rule == grammarAccess.getElementListRule()) {
					sequence_ElementList_KeyedElement_LiteralValue(context, (LiteralValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKeyedElementRule()) {
					sequence_KeyedElement_LiteralValue(context, (LiteralValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLiteralValueRule()
						|| rule == grammarAccess.getElementRule()
						|| rule == grammarAccess.getKeyRule()) {
					sequence_LiteralValue(context, (LiteralValue) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.MAP_TYPE:
				if (rule == grammarAccess.getOperandRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getCompositeLitRule()) {
					sequence_CompositeLit_MapType(context, (MapType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprRule()
						|| rule == grammarAccess.getTypeSwitchGuardRule()) {
					sequence_CompositeLit_MapType_PrimaryExpr(context, (MapType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprLinhaRule()) {
					sequence_CompositeLit_MapType_PrimaryExpr_PrimaryExprLinha(context, (MapType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMapTypeRule()
						|| rule == grammarAccess.getLiteralTypeRule()) {
					sequence_MapType(context, (MapType) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.METHOD_DECL:
				sequence_MethodDecl(context, (MethodDecl) semanticObject); 
				return; 
			case GoPackage.PARAMETER_LIST:
				if (rule == grammarAccess.getFunctionDeclRule()) {
					sequence_FunctionDecl_ParameterList_Signature(context, (ParameterList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprLinhaRule()) {
					sequence_FunctionLit_ParameterList_PrimaryExpr_PrimaryExprLinha_Signature(context, (ParameterList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprRule()
						|| rule == grammarAccess.getTypeSwitchGuardRule()) {
					sequence_FunctionLit_ParameterList_PrimaryExpr_Signature(context, (ParameterList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOperandRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getFunctionLitRule()) {
					sequence_FunctionLit_ParameterList_Signature(context, (ParameterList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMethodDeclRule()) {
					sequence_MethodDecl_ParameterList(context, (ParameterList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getResultRule()
						|| rule == grammarAccess.getParametersRule()
						|| rule == grammarAccess.getParameterListRule()
						|| rule == grammarAccess.getReceiverRule()) {
					sequence_ParameterList(context, (ParameterList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFunctionTypeRule()
						|| rule == grammarAccess.getSignatureRule()
						|| rule == grammarAccess.getInterfaceTypeRule()
						|| rule == grammarAccess.getMethodSpecRule()) {
					sequence_ParameterList_Signature(context, (ParameterList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSouceFileRule()
						|| rule == grammarAccess.getTopLevelDeclRule()
						|| rule == grammarAccess.getTopLevelDeclLinhaRule()) {
					sequence_ParameterList_Signature_topLevelDeclLinha(context, (ParameterList) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.PRIMARY_EXPR:
				if (rule == grammarAccess.getPrimaryExprRule()
						|| rule == grammarAccess.getTypeSwitchGuardRule()) {
					sequence_PrimaryExpr(context, (PrimaryExpr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprLinhaRule()) {
					sequence_PrimaryExpr_PrimaryExprLinha(context, (PrimaryExpr) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.PRIMARY_EXPR_LINHA:
				sequence_PrimaryExprLinha(context, (PrimaryExprLinha) semanticObject); 
				return; 
			case GoPackage.RECV_STMT:
				sequence_RecvStmt(context, (RecvStmt) semanticObject); 
				return; 
			case GoPackage.RETURN_STMT:
				sequence_ReturnStmt(context, (ReturnStmt) semanticObject); 
				return; 
			case GoPackage.SELECT_STMT:
				sequence_SelectStmt(context, (SelectStmt) semanticObject); 
				return; 
			case GoPackage.SIGNATURE:
				if (rule == grammarAccess.getFunctionDeclRule()) {
					sequence_FunctionDecl_Signature(context, (Signature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprLinhaRule()) {
					sequence_FunctionLit_PrimaryExpr_PrimaryExprLinha_Signature(context, (Signature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprRule()
						|| rule == grammarAccess.getTypeSwitchGuardRule()) {
					sequence_FunctionLit_PrimaryExpr_Signature(context, (Signature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOperandRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getFunctionLitRule()) {
					sequence_FunctionLit_Signature(context, (Signature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFunctionTypeRule()
						|| rule == grammarAccess.getSignatureRule()
						|| rule == grammarAccess.getInterfaceTypeRule()
						|| rule == grammarAccess.getMethodSpecRule()) {
					sequence_Signature(context, (Signature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSouceFileRule()
						|| rule == grammarAccess.getTopLevelDeclRule()
						|| rule == grammarAccess.getTopLevelDeclLinhaRule()) {
					sequence_Signature_topLevelDeclLinha(context, (Signature) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case GoPackage.STRUCT_TYPE:
				if (rule == grammarAccess.getPrimaryExprLinhaRule()) {
					sequence_CompositeLit_PrimaryExpr_PrimaryExprLinha_StructType(context, (StructType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprRule()
						|| rule == grammarAccess.getTypeSwitchGuardRule()) {
					sequence_CompositeLit_PrimaryExpr_StructType(context, (StructType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOperandRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getCompositeLitRule()) {
					sequence_CompositeLit_StructType(context, (StructType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStructTypeRule()
						|| rule == grammarAccess.getLiteralTypeRule()) {
					sequence_StructType(context, (StructType) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.SWITCH_STMT:
				sequence_SwitchStmt(context, (SwitchStmt) semanticObject); 
				return; 
			case GoPackage.TYPE_CASE_CLAUSE:
				sequence_TypeCaseClause(context, (TypeCaseClause) semanticObject); 
				return; 
			case GoPackage.TYPE_LIST:
				if (rule == grammarAccess.getTypeCaseClauseRule()) {
					sequence_TypeCaseClause_TypeList(context, (TypeList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeSwitchCaseRule()
						|| rule == grammarAccess.getTypeListRule()) {
					sequence_TypeList(context, (TypeList) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.TYPE_LIT:
				if (rule == grammarAccess.getPrimaryExprLinhaRule()) {
					sequence_Arguments_CompositeLit_Conversion_FunctionLit_MapType_ParameterList_PrimaryExpr_PrimaryExprLinha_Signature_TypeLit(context, (TypeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getArgumentsRule()) {
					sequence_Arguments_TypeLit(context, (TypeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprRule()
						|| rule == grammarAccess.getTypeSwitchGuardRule()) {
					sequence_CompositeLit_Conversion_FunctionLit_MapType_ParameterList_PrimaryExpr_Signature_TypeLit(context, (TypeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOperandRule()
						|| rule == grammarAccess.getLiteralRule()) {
					sequence_CompositeLit_FunctionLit_MapType_ParameterList_Signature_TypeLit(context, (TypeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getCompositeLitRule()) {
					sequence_CompositeLit_MapType_TypeLit(context, (TypeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSouceFileRule()
						|| rule == grammarAccess.getTopLevelDeclRule()) {
					sequence_ConstSpec_ParameterList_Signature_TypeLit_VarSpec_topLevelDeclLinha(context, (TypeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConstDeclRule()
						|| rule == grammarAccess.getConstSpecRule()) {
					sequence_ConstSpec_TypeLit(context, (TypeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDeclarationRule()) {
					sequence_ConstSpec_TypeLit_VarSpec(context, (TypeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConversionRule()) {
					sequence_Conversion_TypeLit(context, (TypeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFunctionDeclRule()) {
					sequence_FunctionDecl_ParameterList_Signature_TypeLit(context, (TypeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFunctionLitRule()) {
					sequence_FunctionLit_ParameterList_Signature_TypeLit(context, (TypeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMapTypeRule()) {
					sequence_MapType_TypeLit(context, (TypeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLiteralTypeRule()) {
					sequence_MapType_TypeLit(context, (TypeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMethodDeclRule()) {
					sequence_MethodDecl_ParameterList_TypeLit(context, (TypeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFunctionTypeRule()
						|| rule == grammarAccess.getSignatureRule()
						|| rule == grammarAccess.getInterfaceTypeRule()
						|| rule == grammarAccess.getMethodSpecRule()) {
					sequence_ParameterList_Signature_TypeLit(context, (TypeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTopLevelDeclLinhaRule()) {
					sequence_ParameterList_Signature_TypeLit_topLevelDeclLinha(context, (TypeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getResultRule()
						|| rule == grammarAccess.getParametersRule()
						|| rule == grammarAccess.getParameterListRule()
						|| rule == grammarAccess.getReceiverRule()) {
					sequence_ParameterList_TypeLit(context, (TypeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeCaseClauseRule()) {
					sequence_TypeCaseClause_TypeList_TypeLit(context, (TypeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeSwitchCaseRule()
						|| rule == grammarAccess.getTypeListRule()) {
					sequence_TypeList_TypeLit(context, (TypeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getTypeLitRule()
						|| rule == grammarAccess.getTypeLitLinhaRule()
						|| rule == grammarAccess.getElementTypeRule()
						|| rule == grammarAccess.getFieldDeclRule()
						|| rule == grammarAccess.getPointerTypeRule()
						|| rule == grammarAccess.getParameterDeclRule()
						|| rule == grammarAccess.getKeyTypeRule()
						|| rule == grammarAccess.getChannelTypeRule()
						|| rule == grammarAccess.getTypeDeclRule()
						|| rule == grammarAccess.getTypeSpecRule()
						|| rule == grammarAccess.getAliasDeclRule()
						|| rule == grammarAccess.getTypeDefRule()
						|| rule == grammarAccess.getLiteralTypeLinhaRule()
						|| rule == grammarAccess.getTypeAssertionRule()
						|| rule == grammarAccess.getMethodExprRule()
						|| rule == grammarAccess.getReceiverTypeRule()) {
					sequence_TypeLit(context, (TypeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVarDeclRule()
						|| rule == grammarAccess.getVarSpecRule()) {
					sequence_TypeLit_VarSpec(context, (TypeLit) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.VAR_SPEC:
				sequence_VarSpec(context, (VarSpec) semanticObject); 
				return; 
			case GoPackage.SWITCH_STMT_LINHA:
				sequence_switch_stmt_linha(context, (switch_stmt_linha) semanticObject); 
				return; 
			case GoPackage.TOP_LEVEL_DECL_LINHA:
				sequence_topLevelDeclLinha(context, (topLevelDeclLinha) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Arguments returns Arguments
	 *
	 * Constraint:
	 *     ExpressionList+=ExpressionList
	 */
	protected void sequence_Arguments(ISerializationContext context, Arguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExprLinha returns TypeLit
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             TypeLitLinha+=TypeLitLinha | 
	 *             StructType+=StructType | 
	 *             PointerType+=PointerType | 
	 *             FunctionType+=FunctionType | 
	 *             InterfaceType+=InterfaceType | 
	 *             MapType+=MapType | 
	 *             ChannelType+=ChannelType
	 *         ) 
	 *         (
	 *             (
	 *                 (
	 *                     (
	 *                         ((ParameterDecl+=ParameterDecl? Result+=Result? FunctionBody+=FunctionBody) | (ElementType+=ElementType? LiteralValue+=LiteralValue)) 
	 *                         PrimaryExprLinha+=PrimaryExprLinha
	 *                     ) | 
	 *                     PrimaryExprLinha+=PrimaryExprLinha | 
	 *                     (Expression+=Expression PrimaryExprLinha+=PrimaryExprLinha)
	 *                 ) 
	 *                 PrimaryExprLinha+=PrimaryExprLinha
	 *             ) | 
	 *             PrimaryExprLinha+=PrimaryExprLinha | 
	 *             (ExpressionList+=ExpressionList? PrimaryExprLinha+=PrimaryExprLinha)
	 *         )
	 *     )
	 */
	protected void sequence_Arguments_CompositeLit_Conversion_FunctionLit_MapType_ParameterList_PrimaryExpr_PrimaryExprLinha_Signature_TypeLit(ISerializationContext context, TypeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExprLinha returns Arguments
	 *
	 * Constraint:
	 *     (ExpressionList+=ExpressionList PrimaryExprLinha+=PrimaryExprLinha)
	 */
	protected void sequence_Arguments_PrimaryExprLinha(ISerializationContext context, Arguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Arguments returns TypeLit
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             TypeLitLinha+=TypeLitLinha | 
	 *             StructType+=StructType | 
	 *             PointerType+=PointerType | 
	 *             FunctionType+=FunctionType | 
	 *             InterfaceType+=InterfaceType | 
	 *             MapType+=MapType | 
	 *             ChannelType+=ChannelType
	 *         ) 
	 *         ExpressionList+=ExpressionList?
	 *     )
	 */
	protected void sequence_Arguments_TypeLit(ISerializationContext context, TypeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assignment returns Expression
	 *
	 * Constraint:
	 *     (ExpressionLinha+=ExpressionLinha Expression+=Expression? ExpressionList+=ExpressionList)
	 */
	protected void sequence_Assignment_Expression_ExpressionList(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForStmt returns Expression
	 *     ForClause returns Expression
	 *
	 * Constraint:
	 *     (
	 *         ExpressionLinha+=ExpressionLinha 
	 *         ((Expression+=Expression? ExpressionList+=ExpressionList?) | Expression+=Expression)? 
	 *         Condition+=Condition? 
	 *         PostStmt+=PostStmt?
	 *     )
	 */
	protected void sequence_Assignment_Expression_ExpressionList_ForClause_SendStmt(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfStmt returns Expression
	 *
	 * Constraint:
	 *     (
	 *         ExpressionLinha+=ExpressionLinha 
	 *         ((Expression+=Expression? ExpressionList+=ExpressionList?) | Expression+=Expression)? 
	 *         Expression+=Expression 
	 *         Block+=Block 
	 *         (IfStmt+=IfStmt | Block+=Block)?
	 *     )
	 */
	protected void sequence_Assignment_Expression_ExpressionList_IfStmt_SendStmt(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStmt returns Expression
	 *     InitStmt returns Expression
	 *     PostStmt returns Expression
	 *
	 * Constraint:
	 *     (ExpressionLinha+=ExpressionLinha ((Expression+=Expression? ExpressionList+=ExpressionList?) | Expression+=Expression)?)
	 */
	protected void sequence_Assignment_Expression_ExpressionList_SendStmt(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SwitchStmt returns Expression
	 *
	 * Constraint:
	 *     (
	 *         ExpressionLinha+=ExpressionLinha 
	 *         ((Expression+=Expression? ExpressionList+=ExpressionList?) | Expression+=Expression)? 
	 *         switch_stmt_linha+=switch_stmt_linha
	 *     )
	 */
	protected void sequence_Assignment_Expression_ExpressionList_SendStmt_SwitchStmt(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns CompositeLit
	 *     Literal returns CompositeLit
	 *     CompositeLit returns CompositeLit
	 *
	 * Constraint:
	 *     LiteralValue+=LiteralValue
	 */
	protected void sequence_CompositeLit(ISerializationContext context, CompositeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns TypeLit
	 *     TypeSwitchGuard returns TypeLit
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             TypeLitLinha+=TypeLitLinha | 
	 *             StructType+=StructType | 
	 *             PointerType+=PointerType | 
	 *             FunctionType+=FunctionType | 
	 *             InterfaceType+=InterfaceType | 
	 *             MapType+=MapType | 
	 *             ChannelType+=ChannelType
	 *         ) 
	 *         (
	 *             (
	 *                 ((ParameterDecl+=ParameterDecl? Result+=Result? FunctionBody+=FunctionBody) | (ElementType+=ElementType? LiteralValue+=LiteralValue)) 
	 *                 PrimaryExprLinha+=PrimaryExprLinha
	 *             ) | 
	 *             PrimaryExprLinha+=PrimaryExprLinha | 
	 *             (Expression+=Expression PrimaryExprLinha+=PrimaryExprLinha)
	 *         )
	 *     )
	 */
	protected void sequence_CompositeLit_Conversion_FunctionLit_MapType_ParameterList_PrimaryExpr_Signature_TypeLit(ISerializationContext context, TypeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExprLinha returns Expression
	 *
	 * Constraint:
	 *     (
	 *         ExpressionLinha+=ExpressionLinha 
	 *         (
	 *             (Expression+=Expression? PrimaryExprLinha+=PrimaryExprLinha) | 
	 *             ((ElementType+=ElementType LiteralValue+=LiteralValue)? PrimaryExprLinha+=PrimaryExprLinha PrimaryExprLinha+=PrimaryExprLinha) | 
	 *             (IndexLinha+=IndexLinha PrimaryExprLinha+=PrimaryExprLinha)
	 *         )
	 *     )
	 */
	protected void sequence_CompositeLit_Expression_ExpressionList_LiteralTypeLinha_PrimaryExpr_PrimaryExprLinha(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns Expression
	 *
	 * Constraint:
	 *     (ExpressionLinha+=ExpressionLinha (ElementType+=ElementType LiteralValue+=LiteralValue)?)
	 */
	protected void sequence_CompositeLit_Expression_LiteralTypeLinha(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     Literal returns Expression
	//     CompositeLit returns Expression
	//
	// Constraint:
	//     (ExpressionLinha+=ExpressionLinha ElementType+=ElementType LiteralValue+=LiteralValue)
	//
	// protected void sequence_CompositeLit_Expression_LiteralTypeLinha(ISerializationContext context, Expression semanticObject) { }
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns Expression
	 *     TypeSwitchGuard returns Expression
	 *
	 * Constraint:
	 *     (ExpressionLinha+=ExpressionLinha (ElementType+=ElementType LiteralValue+=LiteralValue)? PrimaryExprLinha+=PrimaryExprLinha)
	 */
	protected void sequence_CompositeLit_Expression_LiteralTypeLinha_PrimaryExpr(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns TypeLit
	 *     Literal returns TypeLit
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             TypeLitLinha+=TypeLitLinha | 
	 *             StructType+=StructType | 
	 *             PointerType+=PointerType | 
	 *             FunctionType+=FunctionType | 
	 *             InterfaceType+=InterfaceType | 
	 *             MapType+=MapType | 
	 *             ChannelType+=ChannelType
	 *         ) 
	 *         ((ParameterDecl+=ParameterDecl? Result+=Result? FunctionBody+=FunctionBody) | (ElementType+=ElementType? LiteralValue+=LiteralValue))
	 *     )
	 */
	protected void sequence_CompositeLit_FunctionLit_MapType_ParameterList_Signature_TypeLit(ISerializationContext context, TypeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns MapType
	 *     Literal returns MapType
	 *     CompositeLit returns MapType
	 *
	 * Constraint:
	 *     (ElementType+=ElementType LiteralValue+=LiteralValue)
	 */
	protected void sequence_CompositeLit_MapType(ISerializationContext context, MapType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns MapType
	 *     TypeSwitchGuard returns MapType
	 *
	 * Constraint:
	 *     (ElementType+=ElementType LiteralValue+=LiteralValue PrimaryExprLinha+=PrimaryExprLinha)
	 */
	protected void sequence_CompositeLit_MapType_PrimaryExpr(ISerializationContext context, MapType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExprLinha returns MapType
	 *
	 * Constraint:
	 *     (ElementType+=ElementType LiteralValue+=LiteralValue PrimaryExprLinha+=PrimaryExprLinha PrimaryExprLinha+=PrimaryExprLinha)
	 */
	protected void sequence_CompositeLit_MapType_PrimaryExpr_PrimaryExprLinha(ISerializationContext context, MapType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompositeLit returns TypeLit
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             TypeLitLinha+=TypeLitLinha | 
	 *             StructType+=StructType | 
	 *             PointerType+=PointerType | 
	 *             FunctionType+=FunctionType | 
	 *             InterfaceType+=InterfaceType | 
	 *             MapType+=MapType | 
	 *             ChannelType+=ChannelType
	 *         ) 
	 *         ElementType+=ElementType? 
	 *         LiteralValue+=LiteralValue
	 *     )
	 */
	protected void sequence_CompositeLit_MapType_TypeLit(ISerializationContext context, TypeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns CompositeLit
	 *     TypeSwitchGuard returns CompositeLit
	 *
	 * Constraint:
	 *     (LiteralValue+=LiteralValue PrimaryExprLinha+=PrimaryExprLinha)
	 */
	protected void sequence_CompositeLit_PrimaryExpr(ISerializationContext context, CompositeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExprLinha returns CompositeLit
	 *
	 * Constraint:
	 *     (LiteralValue+=LiteralValue PrimaryExprLinha+=PrimaryExprLinha PrimaryExprLinha+=PrimaryExprLinha)
	 */
	protected void sequence_CompositeLit_PrimaryExpr_PrimaryExprLinha(ISerializationContext context, CompositeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExprLinha returns StructType
	 *
	 * Constraint:
	 *     (FieldDecl+=FieldDecl+ LiteralValue+=LiteralValue PrimaryExprLinha+=PrimaryExprLinha PrimaryExprLinha+=PrimaryExprLinha)
	 */
	protected void sequence_CompositeLit_PrimaryExpr_PrimaryExprLinha_StructType(ISerializationContext context, StructType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns StructType
	 *     TypeSwitchGuard returns StructType
	 *
	 * Constraint:
	 *     (FieldDecl+=FieldDecl+ LiteralValue+=LiteralValue PrimaryExprLinha+=PrimaryExprLinha)
	 */
	protected void sequence_CompositeLit_PrimaryExpr_StructType(ISerializationContext context, StructType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns StructType
	 *     Literal returns StructType
	 *     CompositeLit returns StructType
	 *
	 * Constraint:
	 *     (FieldDecl+=FieldDecl+ LiteralValue+=LiteralValue)
	 */
	protected void sequence_CompositeLit_StructType(ISerializationContext context, StructType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SouceFile returns ConstSpec
	 *     Declaration returns ConstSpec
	 *     TopLevelDecl returns ConstSpec
	 *     ConstDecl returns ConstSpec
	 *     ConstSpec returns ConstSpec
	 *
	 * Constraint:
	 *     ExpressionList+=ExpressionList
	 */
	protected void sequence_ConstSpec(ISerializationContext context, ConstSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SouceFile returns TypeLit
	 *     TopLevelDecl returns TypeLit
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             TypeLitLinha+=TypeLitLinha | 
	 *             StructType+=StructType | 
	 *             PointerType+=PointerType | 
	 *             FunctionType+=FunctionType | 
	 *             InterfaceType+=InterfaceType | 
	 *             MapType+=MapType | 
	 *             ChannelType+=ChannelType
	 *         ) 
	 *         (
	 *             (ParameterDecl+=ParameterDecl? ((Result+=Result? FunctionBody+=FunctionBody?) | (Signature+=Signature FunctionBody+=FunctionBody?))) | 
	 *             ExpressionList+=ExpressionList | 
	 *             ExpressionList+=ExpressionList
	 *         )?
	 *     )
	 */
	protected void sequence_ConstSpec_ParameterList_Signature_TypeLit_VarSpec_topLevelDeclLinha(ISerializationContext context, TypeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstDecl returns TypeLit
	 *     ConstSpec returns TypeLit
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             TypeLitLinha+=TypeLitLinha | 
	 *             StructType+=StructType | 
	 *             PointerType+=PointerType | 
	 *             FunctionType+=FunctionType | 
	 *             InterfaceType+=InterfaceType | 
	 *             MapType+=MapType | 
	 *             ChannelType+=ChannelType
	 *         ) 
	 *         ExpressionList+=ExpressionList
	 *     )
	 */
	protected void sequence_ConstSpec_TypeLit(ISerializationContext context, TypeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns TypeLit
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             TypeLitLinha+=TypeLitLinha | 
	 *             StructType+=StructType | 
	 *             PointerType+=PointerType | 
	 *             FunctionType+=FunctionType | 
	 *             InterfaceType+=InterfaceType | 
	 *             MapType+=MapType | 
	 *             ChannelType+=ChannelType
	 *         ) 
	 *         (ExpressionList+=ExpressionList | ExpressionList+=ExpressionList)?
	 *     )
	 */
	protected void sequence_ConstSpec_TypeLit_VarSpec(ISerializationContext context, TypeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Conversion returns Conversion
	 *
	 * Constraint:
	 *     Expression+=Expression
	 */
	protected void sequence_Conversion(ISerializationContext context, Conversion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns Conversion
	 *     TypeSwitchGuard returns Conversion
	 *
	 * Constraint:
	 *     (Expression+=Expression PrimaryExprLinha+=PrimaryExprLinha)
	 */
	protected void sequence_Conversion_PrimaryExpr(ISerializationContext context, Conversion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExprLinha returns Conversion
	 *
	 * Constraint:
	 *     (Expression+=Expression PrimaryExprLinha+=PrimaryExprLinha PrimaryExprLinha+=PrimaryExprLinha)
	 */
	protected void sequence_Conversion_PrimaryExpr_PrimaryExprLinha(ISerializationContext context, Conversion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Conversion returns TypeLit
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             TypeLitLinha+=TypeLitLinha | 
	 *             StructType+=StructType | 
	 *             PointerType+=PointerType | 
	 *             FunctionType+=FunctionType | 
	 *             InterfaceType+=InterfaceType | 
	 *             MapType+=MapType | 
	 *             ChannelType+=ChannelType
	 *         ) 
	 *         Expression+=Expression
	 *     )
	 */
	protected void sequence_Conversion_TypeLit(ISerializationContext context, TypeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeferStmt returns DeferStmt
	 *
	 * Constraint:
	 *     Expression+=Expression
	 */
	protected void sequence_DeferStmt(ISerializationContext context, DeferStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementList returns Key
	 *
	 * Constraint:
	 *     (Expression+=Expression Element+=Element KeyedElement+=KeyedElement?)
	 */
	protected void sequence_ElementList_Key_KeyedElement(ISerializationContext context, Key semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementList returns KeyedElement
	 *
	 * Constraint:
	 *     (Element+=Element KeyedElement+=KeyedElement?)
	 */
	protected void sequence_ElementList_KeyedElement(ISerializationContext context, KeyedElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementList returns LiteralValue
	 *
	 * Constraint:
	 *     (ElementList+=ElementList Element+=Element KeyedElement+=KeyedElement?)
	 */
	protected void sequence_ElementList_KeyedElement_LiteralValue(ISerializationContext context, LiteralValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprCaseClause returns ExprCaseClause
	 *
	 * Constraint:
	 *     StatementList+=StatementList
	 */
	protected void sequence_ExprCaseClause(ISerializationContext context, ExprCaseClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExprCaseClause returns Expression
	 *
	 * Constraint:
	 *     (ExpressionLinha+=ExpressionLinha Expression+=Expression? StatementList+=StatementList)
	 */
	protected void sequence_ExprCaseClause_Expression_ExpressionList(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArrayLength returns Expression
	 *     Element returns Expression
	 *     Expression returns Expression
	 *     ExpressionStmt returns Expression
	 *     Channel returns Expression
	 *     IncDecStmt returns Expression
	 *     Condition returns Expression
	 *     GoStmt returns Expression
	 *     RecvExpr returns Expression
	 *
	 * Constraint:
	 *     ExpressionLinha+=ExpressionLinha
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionLinha returns Expression
	 *
	 * Constraint:
	 *     (ExpressionLinha+=ExpressionLinha ExpressionLinha+=ExpressionLinha)
	 */
	protected void sequence_Expression_ExpressionLinha(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SouceFile returns Expression
	 *     Declaration returns Expression
	 *     TopLevelDecl returns Expression
	 *     ExpressionList returns Expression
	 *     VarDecl returns Expression
	 *     VarSpec returns Expression
	 *     ShortVarDecl returns Expression
	 *     Arguments returns Expression
	 *     ExprSwitchCase returns Expression
	 *     RangeClause returns Expression
	 *
	 * Constraint:
	 *     (ExpressionLinha+=ExpressionLinha Expression+=Expression?)
	 */
	protected void sequence_Expression_ExpressionList(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RecvStmt returns Expression
	 *
	 * Constraint:
	 *     (ExpressionLinha+=ExpressionLinha Expression+=Expression? RecvExpr+=RecvExpr)
	 */
	protected void sequence_Expression_ExpressionList_RecvStmt(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommClause returns Expression
	 *     CommCase returns Expression
	 *
	 * Constraint:
	 *     (ExpressionLinha+=ExpressionLinha ((Expression+=Expression? RecvExpr+=RecvExpr) | Expression+=Expression))
	 */
	protected void sequence_Expression_ExpressionList_RecvStmt_SendStmt(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LiteralType returns Expression
	 *     LiteralTypeLinha returns Expression
	 *
	 * Constraint:
	 *     (ExpressionLinha+=ExpressionLinha ElementType+=ElementType)
	 */
	protected void sequence_Expression_LiteralTypeLinha(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SendStmt returns Expression
	 *
	 * Constraint:
	 *     (ExpressionLinha+=ExpressionLinha Expression+=Expression)
	 */
	protected void sequence_Expression_SendStmt(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeLitLinha returns Expression
	 *
	 * Constraint:
	 *     (ExpressionLinha+=ExpressionLinha ElementType+=ElementType)
	 */
	protected void sequence_Expression_TypeLitLinha(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ForStmt returns ForClause
	 *     ForClause returns ForClause
	 *
	 * Constraint:
	 *     (Condition+=Condition? PostStmt+=PostStmt?)
	 */
	protected void sequence_ForClause(ISerializationContext context, ForClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDecl returns FunctionDecl
	 *
	 * Constraint:
	 *     FunctionBody+=FunctionBody
	 */
	protected void sequence_FunctionDecl(ISerializationContext context, FunctionDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDecl returns ParameterList
	 *
	 * Constraint:
	 *     (ParameterDecl+=ParameterDecl Result+=Result? FunctionBody+=FunctionBody?)
	 */
	protected void sequence_FunctionDecl_ParameterList_Signature(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDecl returns TypeLit
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             TypeLitLinha+=TypeLitLinha | 
	 *             StructType+=StructType | 
	 *             PointerType+=PointerType | 
	 *             FunctionType+=FunctionType | 
	 *             InterfaceType+=InterfaceType | 
	 *             MapType+=MapType | 
	 *             ChannelType+=ChannelType
	 *         ) 
	 *         ParameterDecl+=ParameterDecl? 
	 *         Result+=Result? 
	 *         FunctionBody+=FunctionBody?
	 *     )
	 */
	protected void sequence_FunctionDecl_ParameterList_Signature_TypeLit(ISerializationContext context, TypeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDecl returns Signature
	 *
	 * Constraint:
	 *     (Result+=Result FunctionBody+=FunctionBody?)
	 */
	protected void sequence_FunctionDecl_Signature(ISerializationContext context, Signature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns FunctionLit
	 *     Literal returns FunctionLit
	 *     FunctionLit returns FunctionLit
	 *
	 * Constraint:
	 *     FunctionBody+=FunctionBody
	 */
	protected void sequence_FunctionLit(ISerializationContext context, FunctionLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExprLinha returns ParameterList
	 *
	 * Constraint:
	 *     (ParameterDecl+=ParameterDecl Result+=Result? FunctionBody+=FunctionBody PrimaryExprLinha+=PrimaryExprLinha PrimaryExprLinha+=PrimaryExprLinha)
	 */
	protected void sequence_FunctionLit_ParameterList_PrimaryExpr_PrimaryExprLinha_Signature(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns ParameterList
	 *     TypeSwitchGuard returns ParameterList
	 *
	 * Constraint:
	 *     (ParameterDecl+=ParameterDecl Result+=Result? FunctionBody+=FunctionBody PrimaryExprLinha+=PrimaryExprLinha)
	 */
	protected void sequence_FunctionLit_ParameterList_PrimaryExpr_Signature(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns ParameterList
	 *     Literal returns ParameterList
	 *     FunctionLit returns ParameterList
	 *
	 * Constraint:
	 *     (ParameterDecl+=ParameterDecl Result+=Result? FunctionBody+=FunctionBody)
	 */
	protected void sequence_FunctionLit_ParameterList_Signature(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionLit returns TypeLit
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             TypeLitLinha+=TypeLitLinha | 
	 *             StructType+=StructType | 
	 *             PointerType+=PointerType | 
	 *             FunctionType+=FunctionType | 
	 *             InterfaceType+=InterfaceType | 
	 *             MapType+=MapType | 
	 *             ChannelType+=ChannelType
	 *         ) 
	 *         ParameterDecl+=ParameterDecl? 
	 *         Result+=Result? 
	 *         FunctionBody+=FunctionBody
	 *     )
	 */
	protected void sequence_FunctionLit_ParameterList_Signature_TypeLit(ISerializationContext context, TypeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns FunctionLit
	 *     TypeSwitchGuard returns FunctionLit
	 *
	 * Constraint:
	 *     (FunctionBody+=FunctionBody PrimaryExprLinha+=PrimaryExprLinha)
	 */
	protected void sequence_FunctionLit_PrimaryExpr(ISerializationContext context, FunctionLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExprLinha returns FunctionLit
	 *
	 * Constraint:
	 *     (FunctionBody+=FunctionBody PrimaryExprLinha+=PrimaryExprLinha PrimaryExprLinha+=PrimaryExprLinha)
	 */
	protected void sequence_FunctionLit_PrimaryExpr_PrimaryExprLinha(ISerializationContext context, FunctionLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExprLinha returns Signature
	 *
	 * Constraint:
	 *     (Result+=Result FunctionBody+=FunctionBody PrimaryExprLinha+=PrimaryExprLinha PrimaryExprLinha+=PrimaryExprLinha)
	 */
	protected void sequence_FunctionLit_PrimaryExpr_PrimaryExprLinha_Signature(ISerializationContext context, Signature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns Signature
	 *     TypeSwitchGuard returns Signature
	 *
	 * Constraint:
	 *     (Result+=Result FunctionBody+=FunctionBody PrimaryExprLinha+=PrimaryExprLinha)
	 */
	protected void sequence_FunctionLit_PrimaryExpr_Signature(ISerializationContext context, Signature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns Signature
	 *     Literal returns Signature
	 *     FunctionLit returns Signature
	 *
	 * Constraint:
	 *     (Result+=Result FunctionBody+=FunctionBody)
	 */
	protected void sequence_FunctionLit_Signature(ISerializationContext context, Signature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfStmt returns IfStmt
	 *
	 * Constraint:
	 *     (Expression+=Expression Block+=Block (IfStmt+=IfStmt | Block+=Block)?)
	 */
	protected void sequence_IfStmt(ISerializationContext context, IfStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Key returns Key
	 *
	 * Constraint:
	 *     Expression+=Expression
	 */
	protected void sequence_Key(ISerializationContext context, Key semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KeyedElement returns Key
	 *
	 * Constraint:
	 *     (Expression+=Expression Element+=Element)
	 */
	protected void sequence_Key_KeyedElement(ISerializationContext context, Key semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KeyedElement returns KeyedElement
	 *
	 * Constraint:
	 *     Element+=Element
	 */
	protected void sequence_KeyedElement(ISerializationContext context, KeyedElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KeyedElement returns LiteralValue
	 *
	 * Constraint:
	 *     (ElementList+=ElementList Element+=Element)
	 */
	protected void sequence_KeyedElement_LiteralValue(ISerializationContext context, LiteralValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LiteralValue returns LiteralValue
	 *     Element returns LiteralValue
	 *     Key returns LiteralValue
	 *
	 * Constraint:
	 *     ElementList+=ElementList
	 */
	protected void sequence_LiteralValue(ISerializationContext context, LiteralValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapType returns MapType
	 *     LiteralType returns MapType
	 *
	 * Constraint:
	 *     ElementType+=ElementType
	 */
	protected void sequence_MapType(ISerializationContext context, MapType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapType returns TypeLit
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             TypeLitLinha+=TypeLitLinha | 
	 *             StructType+=StructType | 
	 *             PointerType+=PointerType | 
	 *             FunctionType+=FunctionType | 
	 *             InterfaceType+=InterfaceType | 
	 *             MapType+=MapType | 
	 *             ChannelType+=ChannelType
	 *         ) 
	 *         ElementType+=ElementType
	 *     )
	 */
	protected void sequence_MapType_TypeLit(ISerializationContext context, TypeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     LiteralType returns TypeLit
	//
	// Constraint:
	//     (
	//         (
	//             TypeLitLinha+=TypeLitLinha | 
	//             StructType+=StructType | 
	//             PointerType+=PointerType | 
	//             FunctionType+=FunctionType | 
	//             InterfaceType+=InterfaceType | 
	//             MapType+=MapType | 
	//             ChannelType+=ChannelType
	//         ) 
	//         ElementType+=ElementType?
	//     )
	//
	// protected void sequence_MapType_TypeLit(ISerializationContext context, TypeLit semanticObject) { }
	
	/**
	 * Contexts:
	 *     MethodDecl returns MethodDecl
	 *
	 * Constraint:
	 *     (Signature+=Signature FunctionBody+=FunctionBody?)
	 */
	protected void sequence_MethodDecl(ISerializationContext context, MethodDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodDecl returns ParameterList
	 *
	 * Constraint:
	 *     (ParameterDecl+=ParameterDecl Signature+=Signature FunctionBody+=FunctionBody?)
	 */
	protected void sequence_MethodDecl_ParameterList(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodDecl returns TypeLit
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             TypeLitLinha+=TypeLitLinha | 
	 *             StructType+=StructType | 
	 *             PointerType+=PointerType | 
	 *             FunctionType+=FunctionType | 
	 *             InterfaceType+=InterfaceType | 
	 *             MapType+=MapType | 
	 *             ChannelType+=ChannelType
	 *         ) 
	 *         ParameterDecl+=ParameterDecl? 
	 *         Signature+=Signature 
	 *         FunctionBody+=FunctionBody?
	 *     )
	 */
	protected void sequence_MethodDecl_ParameterList_TypeLit(ISerializationContext context, TypeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Result returns ParameterList
	 *     Parameters returns ParameterList
	 *     ParameterList returns ParameterList
	 *     Receiver returns ParameterList
	 *
	 * Constraint:
	 *     ParameterDecl+=ParameterDecl
	 */
	protected void sequence_ParameterList(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionType returns ParameterList
	 *     Signature returns ParameterList
	 *     InterfaceType returns ParameterList
	 *     MethodSpec returns ParameterList
	 *
	 * Constraint:
	 *     (ParameterDecl+=ParameterDecl Result+=Result?)
	 */
	protected void sequence_ParameterList_Signature(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionType returns TypeLit
	 *     Signature returns TypeLit
	 *     InterfaceType returns TypeLit
	 *     MethodSpec returns TypeLit
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             TypeLitLinha+=TypeLitLinha | 
	 *             StructType+=StructType | 
	 *             PointerType+=PointerType | 
	 *             FunctionType+=FunctionType | 
	 *             InterfaceType+=InterfaceType | 
	 *             MapType+=MapType | 
	 *             ChannelType+=ChannelType
	 *         ) 
	 *         ParameterDecl+=ParameterDecl? 
	 *         Result+=Result?
	 *     )
	 */
	protected void sequence_ParameterList_Signature_TypeLit(ISerializationContext context, TypeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     topLevelDeclLinha returns TypeLit
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             TypeLitLinha+=TypeLitLinha | 
	 *             StructType+=StructType | 
	 *             PointerType+=PointerType | 
	 *             FunctionType+=FunctionType | 
	 *             InterfaceType+=InterfaceType | 
	 *             MapType+=MapType | 
	 *             ChannelType+=ChannelType
	 *         ) 
	 *         ParameterDecl+=ParameterDecl? 
	 *         ((Result+=Result? FunctionBody+=FunctionBody?) | (Signature+=Signature FunctionBody+=FunctionBody?))
	 *     )
	 */
	protected void sequence_ParameterList_Signature_TypeLit_topLevelDeclLinha(ISerializationContext context, TypeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SouceFile returns ParameterList
	 *     TopLevelDecl returns ParameterList
	 *     topLevelDeclLinha returns ParameterList
	 *
	 * Constraint:
	 *     (ParameterDecl+=ParameterDecl ((Result+=Result? FunctionBody+=FunctionBody?) | (Signature+=Signature FunctionBody+=FunctionBody?)))
	 */
	protected void sequence_ParameterList_Signature_topLevelDeclLinha(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Result returns TypeLit
	 *     Parameters returns TypeLit
	 *     ParameterList returns TypeLit
	 *     Receiver returns TypeLit
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             TypeLitLinha+=TypeLitLinha | 
	 *             StructType+=StructType | 
	 *             PointerType+=PointerType | 
	 *             FunctionType+=FunctionType | 
	 *             InterfaceType+=InterfaceType | 
	 *             MapType+=MapType | 
	 *             ChannelType+=ChannelType
	 *         ) 
	 *         ParameterDecl+=ParameterDecl?
	 *     )
	 */
	protected void sequence_ParameterList_TypeLit(ISerializationContext context, TypeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExprLinha returns PrimaryExprLinha
	 *
	 * Constraint:
	 *     ((IndexLinha+=IndexLinha PrimaryExprLinha+=PrimaryExprLinha) | PrimaryExprLinha+=PrimaryExprLinha | PrimaryExprLinha+=PrimaryExprLinha)
	 */
	protected void sequence_PrimaryExprLinha(ISerializationContext context, PrimaryExprLinha semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns PrimaryExpr
	 *     TypeSwitchGuard returns PrimaryExpr
	 *
	 * Constraint:
	 *     (PrimaryExprLinha+=PrimaryExprLinha | PrimaryExprLinha+=PrimaryExprLinha)
	 */
	protected void sequence_PrimaryExpr(ISerializationContext context, PrimaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExprLinha returns PrimaryExpr
	 *
	 * Constraint:
	 *     ((PrimaryExprLinha+=PrimaryExprLinha | PrimaryExprLinha+=PrimaryExprLinha) PrimaryExprLinha+=PrimaryExprLinha)
	 */
	protected void sequence_PrimaryExpr_PrimaryExprLinha(ISerializationContext context, PrimaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommClause returns RecvStmt
	 *     CommCase returns RecvStmt
	 *     RecvStmt returns RecvStmt
	 *
	 * Constraint:
	 *     RecvExpr+=RecvExpr
	 */
	protected void sequence_RecvStmt(ISerializationContext context, RecvStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReturnStmt returns ReturnStmt
	 *
	 * Constraint:
	 *     ExpressionList+=ExpressionList
	 */
	protected void sequence_ReturnStmt(ISerializationContext context, ReturnStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SelectStmt returns SelectStmt
	 *
	 * Constraint:
	 *     CommClause+=CommClause+
	 */
	protected void sequence_SelectStmt(ISerializationContext context, SelectStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionType returns Signature
	 *     Signature returns Signature
	 *     InterfaceType returns Signature
	 *     MethodSpec returns Signature
	 *
	 * Constraint:
	 *     Result+=Result
	 */
	protected void sequence_Signature(ISerializationContext context, Signature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SouceFile returns Signature
	 *     TopLevelDecl returns Signature
	 *     topLevelDeclLinha returns Signature
	 *
	 * Constraint:
	 *     (Result+=Result FunctionBody+=FunctionBody?)
	 */
	protected void sequence_Signature_topLevelDeclLinha(ISerializationContext context, Signature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Block returns Statement
	 *     StatementList returns Statement
	 *     FunctionBody returns Statement
	 *     Statement returns Statement
	 *     LabeledStmt returns Statement
	 *
	 * Constraint:
	 *     (
	 *         Declaration+=Declaration | 
	 *         LabeledStmt+=LabeledStmt | 
	 *         SimpleStmt+=SimpleStmt | 
	 *         GoStmt+=GoStmt | 
	 *         ReturnStmt+=ReturnStmt | 
	 *         BreakStmt+=BreakStmt | 
	 *         ContinueStmt+=ContinueStmt | 
	 *         GotoStmt+=GotoStmt | 
	 *         FallthroughStmt+=FallthroughStmt | 
	 *         Block+=Block | 
	 *         IfStmt+=IfStmt | 
	 *         SwitchStmt+=SwitchStmt | 
	 *         SelectStmt+=SelectStmt | 
	 *         ForStmt+=ForStmt | 
	 *         DeferStmt+=DeferStmt
	 *     )
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StructType returns StructType
	 *     LiteralType returns StructType
	 *
	 * Constraint:
	 *     FieldDecl+=FieldDecl+
	 */
	protected void sequence_StructType(ISerializationContext context, StructType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SwitchStmt returns SwitchStmt
	 *
	 * Constraint:
	 *     switch_stmt_linha+=switch_stmt_linha
	 */
	protected void sequence_SwitchStmt(ISerializationContext context, SwitchStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeCaseClause returns TypeCaseClause
	 *
	 * Constraint:
	 *     StatementList+=StatementList
	 */
	protected void sequence_TypeCaseClause(ISerializationContext context, TypeCaseClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeCaseClause returns TypeList
	 *
	 * Constraint:
	 *     (Type+=Type+ StatementList+=StatementList)
	 */
	protected void sequence_TypeCaseClause_TypeList(ISerializationContext context, TypeList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeCaseClause returns TypeLit
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             TypeLitLinha+=TypeLitLinha | 
	 *             StructType+=StructType | 
	 *             PointerType+=PointerType | 
	 *             FunctionType+=FunctionType | 
	 *             InterfaceType+=InterfaceType | 
	 *             MapType+=MapType | 
	 *             ChannelType+=ChannelType
	 *         ) 
	 *         Type+=Type* 
	 *         StatementList+=StatementList
	 *     )
	 */
	protected void sequence_TypeCaseClause_TypeList_TypeLit(ISerializationContext context, TypeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSwitchCase returns TypeList
	 *     TypeList returns TypeList
	 *
	 * Constraint:
	 *     Type+=Type+
	 */
	protected void sequence_TypeList(ISerializationContext context, TypeList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSwitchCase returns TypeLit
	 *     TypeList returns TypeLit
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             TypeLitLinha+=TypeLitLinha | 
	 *             StructType+=StructType | 
	 *             PointerType+=PointerType | 
	 *             FunctionType+=FunctionType | 
	 *             InterfaceType+=InterfaceType | 
	 *             MapType+=MapType | 
	 *             ChannelType+=ChannelType
	 *         ) 
	 *         Type+=Type*
	 *     )
	 */
	protected void sequence_TypeList_TypeLit(ISerializationContext context, TypeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns TypeLit
	 *     TypeLit returns TypeLit
	 *     TypeLitLinha returns TypeLit
	 *     ElementType returns TypeLit
	 *     FieldDecl returns TypeLit
	 *     PointerType returns TypeLit
	 *     ParameterDecl returns TypeLit
	 *     KeyType returns TypeLit
	 *     ChannelType returns TypeLit
	 *     TypeDecl returns TypeLit
	 *     TypeSpec returns TypeLit
	 *     AliasDecl returns TypeLit
	 *     TypeDef returns TypeLit
	 *     LiteralTypeLinha returns TypeLit
	 *     TypeAssertion returns TypeLit
	 *     MethodExpr returns TypeLit
	 *     ReceiverType returns TypeLit
	 *
	 * Constraint:
	 *     (
	 *         TypeLitLinha+=TypeLitLinha | 
	 *         StructType+=StructType | 
	 *         PointerType+=PointerType | 
	 *         FunctionType+=FunctionType | 
	 *         InterfaceType+=InterfaceType | 
	 *         MapType+=MapType | 
	 *         ChannelType+=ChannelType
	 *     )
	 */
	protected void sequence_TypeLit(ISerializationContext context, TypeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarDecl returns TypeLit
	 *     VarSpec returns TypeLit
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             TypeLitLinha+=TypeLitLinha | 
	 *             StructType+=StructType | 
	 *             PointerType+=PointerType | 
	 *             FunctionType+=FunctionType | 
	 *             InterfaceType+=InterfaceType | 
	 *             MapType+=MapType | 
	 *             ChannelType+=ChannelType
	 *         ) 
	 *         ExpressionList+=ExpressionList?
	 *     )
	 */
	protected void sequence_TypeLit_VarSpec(ISerializationContext context, TypeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SouceFile returns VarSpec
	 *     Declaration returns VarSpec
	 *     TopLevelDecl returns VarSpec
	 *     VarDecl returns VarSpec
	 *     VarSpec returns VarSpec
	 *
	 * Constraint:
	 *     ExpressionList+=ExpressionList
	 */
	protected void sequence_VarSpec(ISerializationContext context, VarSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     switch_stmt_linha returns switch_stmt_linha
	 *
	 * Constraint:
	 *     ((TypeSwitchGuard+=TypeSwitchGuard TypeCaseClause+=TypeCaseClause*) | (Expression+=Expression? ExprCaseClause+=ExprCaseClause*))
	 */
	protected void sequence_switch_stmt_linha(ISerializationContext context, switch_stmt_linha semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SouceFile returns topLevelDeclLinha
	 *     TopLevelDecl returns topLevelDeclLinha
	 *     topLevelDeclLinha returns topLevelDeclLinha
	 *
	 * Constraint:
	 *     (FunctionBody+=FunctionBody | (Signature+=Signature FunctionBody+=FunctionBody?))
	 */
	protected void sequence_topLevelDeclLinha(ISerializationContext context, topLevelDeclLinha semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
