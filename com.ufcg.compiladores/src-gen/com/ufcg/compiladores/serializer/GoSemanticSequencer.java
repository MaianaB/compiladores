/*
 * generated by Xtext 2.13.0
 */
package com.ufcg.compiladores.serializer;

import com.google.inject.Inject;
import com.ufcg.compiladores.go.Arguments;
import com.ufcg.compiladores.go.BaseType;
import com.ufcg.compiladores.go.CompositeLit;
import com.ufcg.compiladores.go.ConstSpec;
import com.ufcg.compiladores.go.Conversion;
import com.ufcg.compiladores.go.ElementType;
import com.ufcg.compiladores.go.FunctionLit;
import com.ufcg.compiladores.go.FunctionType;
import com.ufcg.compiladores.go.GoPackage;
import com.ufcg.compiladores.go.Greeting;
import com.ufcg.compiladores.go.InterfaceType;
import com.ufcg.compiladores.go.KeyType;
import com.ufcg.compiladores.go.KeyedElement;
import com.ufcg.compiladores.go.LiteralType;
import com.ufcg.compiladores.go.LiteralValue;
import com.ufcg.compiladores.go.MethodDecl;
import com.ufcg.compiladores.go.Model;
import com.ufcg.compiladores.go.ParameterList;
import com.ufcg.compiladores.go.PrimaryExpr;
import com.ufcg.compiladores.go.Signature;
import com.ufcg.compiladores.go.Slice;
import com.ufcg.compiladores.go.StructType;
import com.ufcg.compiladores.go.Type;
import com.ufcg.compiladores.go.UnaryExpr;
import com.ufcg.compiladores.go.VarSpec;
import com.ufcg.compiladores.services.GoGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class GoSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GoGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GoPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GoPackage.ARGUMENTS:
				sequence_Arguments(context, (Arguments) semanticObject); 
				return; 
			case GoPackage.BASE_TYPE:
				sequence_BaseType(context, (BaseType) semanticObject); 
				return; 
			case GoPackage.COMPOSITE_LIT:
				if (rule == grammarAccess.getOperandRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getCompositeLitRule()) {
					sequence_CompositeLit(context, (CompositeLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprRule()) {
					sequence_CompositeLit_PrimaryExpr(context, (CompositeLit) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.CONST_SPEC:
				sequence_ConstSpec(context, (ConstSpec) semanticObject); 
				return; 
			case GoPackage.CONVERSION:
				if (rule == grammarAccess.getConversionRule()) {
					sequence_Conversion(context, (Conversion) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprRule()) {
					sequence_Conversion_PrimaryExpr(context, (Conversion) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.ELEMENT_TYPE:
				if (rule == grammarAccess.getOperandRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getCompositeLitRule()) {
					sequence_CompositeLit_ElementType(context, (ElementType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprRule()) {
					sequence_CompositeLit_ElementType_PrimaryExpr(context, (ElementType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeLitRule()
						|| rule == grammarAccess.getElementTypeRule()
						|| rule == grammarAccess.getSliceTypeRule()
						|| rule == grammarAccess.getChannelTypeRule()
						|| rule == grammarAccess.getLiteralTypeRule()) {
					sequence_ElementType(context, (ElementType) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.FUNCTION_LIT:
				if (rule == grammarAccess.getOperandRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getFunctionLitRule()) {
					sequence_FunctionLit(context, (FunctionLit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprRule()) {
					sequence_FunctionLit_PrimaryExpr(context, (FunctionLit) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.FUNCTION_TYPE:
				sequence_FunctionType(context, (FunctionType) semanticObject); 
				return; 
			case GoPackage.GREETING:
				sequence_Greeting(context, (Greeting) semanticObject); 
				return; 
			case GoPackage.INTERFACE_TYPE:
				sequence_InterfaceType(context, (InterfaceType) semanticObject); 
				return; 
			case GoPackage.KEY_TYPE:
				if (rule == grammarAccess.getOperandRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getCompositeLitRule()) {
					sequence_CompositeLit_KeyType_MapType(context, (KeyType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprRule()) {
					sequence_CompositeLit_KeyType_MapType_PrimaryExpr(context, (KeyType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKeyTypeRule()) {
					sequence_KeyType(context, (KeyType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeLitRule()
						|| rule == grammarAccess.getMapTypeRule()
						|| rule == grammarAccess.getLiteralTypeRule()) {
					sequence_KeyType_MapType(context, (KeyType) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.KEYED_ELEMENT:
				if (rule == grammarAccess.getElementListRule()) {
					sequence_ElementList_KeyedElement(context, (KeyedElement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKeyedElementRule()) {
					sequence_KeyedElement(context, (KeyedElement) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.LITERAL_TYPE:
				if (rule == grammarAccess.getOperandRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getCompositeLitRule()) {
					sequence_CompositeLit_LiteralType(context, (LiteralType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprRule()) {
					sequence_CompositeLit_LiteralType_PrimaryExpr(context, (LiteralType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLiteralTypeRule()) {
					sequence_LiteralType(context, (LiteralType) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.LITERAL_VALUE:
				if (rule == grammarAccess.getElementListRule()) {
					sequence_ElementList_KeyedElement_LiteralValue(context, (LiteralValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKeyedElementRule()) {
					sequence_KeyedElement_LiteralValue(context, (LiteralValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLiteralValueRule()
						|| rule == grammarAccess.getElementRule()
						|| rule == grammarAccess.getKeyRule()) {
					sequence_LiteralValue(context, (LiteralValue) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.METHOD_DECL:
				sequence_MethodDecl(context, (MethodDecl) semanticObject); 
				return; 
			case GoPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case GoPackage.PARAMETER_LIST:
				if (rule == grammarAccess.getPrimaryExprRule()) {
					sequence_FunctionLit_ParameterList_PrimaryExpr_Signature(context, (ParameterList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOperandRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getFunctionLitRule()) {
					sequence_FunctionLit_ParameterList_Signature(context, (ParameterList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMethodDeclRule()) {
					sequence_MethodDecl_ParameterList(context, (ParameterList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTopLevelDeclRule()) {
					sequence_MethodDecl_ParameterList_Signature(context, (ParameterList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getResultRule()
						|| rule == grammarAccess.getParametersRule()
						|| rule == grammarAccess.getParameterListRule()
						|| rule == grammarAccess.getReceiverRule()) {
					sequence_ParameterList(context, (ParameterList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSignatureRule()
						|| rule == grammarAccess.getMethodSpecRule()
						|| rule == grammarAccess.getFunctionDeclRule()) {
					sequence_ParameterList_Signature(context, (ParameterList) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.PRIMARY_EXPR:
				sequence_PrimaryExpr(context, (PrimaryExpr) semanticObject); 
				return; 
			case GoPackage.SIGNATURE:
				if (rule == grammarAccess.getPrimaryExprRule()) {
					sequence_FunctionLit_PrimaryExpr_Signature(context, (Signature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOperandRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getFunctionLitRule()) {
					sequence_FunctionLit_Signature(context, (Signature) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSignatureRule()
						|| rule == grammarAccess.getMethodSpecRule()
						|| rule == grammarAccess.getTopLevelDeclRule()
						|| rule == grammarAccess.getFunctionDeclRule()) {
					sequence_Signature(context, (Signature) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.SLICE:
				sequence_Slice(context, (Slice) semanticObject); 
				return; 
			case GoPackage.STRUCT_TYPE:
				if (rule == grammarAccess.getPrimaryExprRule()) {
					sequence_CompositeLit_PrimaryExpr_StructType(context, (StructType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOperandRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getCompositeLitRule()) {
					sequence_CompositeLit_StructType(context, (StructType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeLitRule()
						|| rule == grammarAccess.getStructTypeRule()
						|| rule == grammarAccess.getLiteralTypeRule()) {
					sequence_StructType(context, (StructType) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.TYPE:
				if (rule == grammarAccess.getArgumentsRule()) {
					sequence_Arguments_Type(context, (Type) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTopLevelDeclRule()) {
					sequence_ConstSpec_MethodDecl_ParameterList_Signature_Type_VarSpec(context, (Type) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConstDeclRule()
						|| rule == grammarAccess.getConstSpecRule()) {
					sequence_ConstSpec_Type(context, (Type) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDeclarationRule()) {
					sequence_ConstSpec_Type_VarSpec(context, (Type) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprRule()) {
					sequence_Conversion_FunctionLit_ParameterList_PrimaryExpr_Signature_Type(context, (Type) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConversionRule()) {
					sequence_Conversion_Type(context, (Type) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOperandRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getFunctionLitRule()) {
					sequence_FunctionLit_ParameterList_Signature_Type(context, (Type) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMethodDeclRule()) {
					sequence_MethodDecl_ParameterList_Type(context, (Type) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSignatureRule()
						|| rule == grammarAccess.getMethodSpecRule()
						|| rule == grammarAccess.getFunctionDeclRule()) {
					sequence_ParameterList_Signature_Type(context, (Type) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getResultRule()
						|| rule == grammarAccess.getParametersRule()
						|| rule == grammarAccess.getParameterListRule()
						|| rule == grammarAccess.getReceiverRule()) {
					sequence_ParameterList_Type(context, (Type) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getFieldDeclRule()
						|| rule == grammarAccess.getParameterDeclRule()
						|| rule == grammarAccess.getTypeDeclRule()
						|| rule == grammarAccess.getTypeSpecRule()
						|| rule == grammarAccess.getAliasDeclRule()
						|| rule == grammarAccess.getTypeDefRule()
						|| rule == grammarAccess.getTypeAssertionRule()
						|| rule == grammarAccess.getMethodExprRule()
						|| rule == grammarAccess.getReceiverTypeRule()) {
					sequence_Type(context, (Type) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVarDeclRule()
						|| rule == grammarAccess.getVarSpecRule()) {
					sequence_Type_VarSpec(context, (Type) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.UNARY_EXPR:
				if (rule == grammarAccess.getTypeLitRule()
						|| rule == grammarAccess.getArrayTypeRule()) {
					sequence_ArrayType_Expression_UnaryExpr(context, (UnaryExpr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getElementListRule()) {
					sequence_ElementList_Expression_KeyedElement_UnaryExpr(context, (UnaryExpr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDeclarationRule()
						|| rule == grammarAccess.getTopLevelDeclRule()
						|| rule == grammarAccess.getExpressionListRule()
						|| rule == grammarAccess.getVarDeclRule()
						|| rule == grammarAccess.getVarSpecRule()
						|| rule == grammarAccess.getShortVarDeclRule()
						|| rule == grammarAccess.getArgumentsRule()) {
					sequence_Expression_ExpressionList_UnaryExpr(context, (UnaryExpr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKeyedElementRule()) {
					sequence_Expression_KeyedElement_UnaryExpr(context, (UnaryExpr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPrimaryExprRule()) {
					sequence_Expression_PrimaryExpr_UnaryExpr(context, (UnaryExpr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSliceRule()) {
					sequence_Expression_Slice_UnaryExpr(context, (UnaryExpr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getArrayLengthRule()
						|| rule == grammarAccess.getOperandRule()
						|| rule == grammarAccess.getElementRule()
						|| rule == grammarAccess.getKeyRule()
						|| rule == grammarAccess.getIndexRule()
						|| rule == grammarAccess.getSliceLinhaRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getExpressionLinhaRule()) {
					sequence_Expression_UnaryExpr(context, (UnaryExpr) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnaryExprRule()) {
					sequence_UnaryExpr(context, (UnaryExpr) semanticObject); 
					return; 
				}
				else break;
			case GoPackage.VAR_SPEC:
				sequence_VarSpec(context, (VarSpec) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Arguments returns Arguments
	 *
	 * Constraint:
	 *     ExpressionList=ExpressionList
	 */
	protected void sequence_Arguments(ISerializationContext context, Arguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Arguments returns Type
	 *
	 * Constraint:
	 *     (TypeLit=TypeLit ExpressionList=ExpressionList?)
	 */
	protected void sequence_Arguments_Type(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeLit returns UnaryExpr
	 *     ArrayType returns UnaryExpr
	 *
	 * Constraint:
	 *     (PrimaryExpr=PrimaryExpr ExpressionLinha=ExpressionLinha Type=Type)
	 */
	protected void sequence_ArrayType_Expression_UnaryExpr(ISerializationContext context, UnaryExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.UNARY_EXPR__PRIMARY_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.UNARY_EXPR__PRIMARY_EXPR));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.UNARY_EXPR__EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.UNARY_EXPR__EXPRESSION_LINHA));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.ARRAY_LENGTH__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.ARRAY_LENGTH__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExprAccess().getPrimaryExprPrimaryExprParserRuleCall_0_0(), semanticObject.getPrimaryExpr());
		feeder.accept(grammarAccess.getExpressionAccess().getExpressionLinhaExpressionLinhaParserRuleCall_1_0(), semanticObject.getExpressionLinha());
		feeder.accept(grammarAccess.getArrayTypeAccess().getTypeTypeParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeLit returns BaseType
	 *     PointerType returns BaseType
	 *     BaseType returns BaseType
	 *
	 * Constraint:
	 *     Type=Type
	 */
	protected void sequence_BaseType(ISerializationContext context, BaseType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.BASE_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.BASE_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBaseTypeAccess().getTypeTypeParserRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns CompositeLit
	 *     Literal returns CompositeLit
	 *     CompositeLit returns CompositeLit
	 *
	 * Constraint:
	 *     LiteralValue=LiteralValue
	 */
	protected void sequence_CompositeLit(ISerializationContext context, CompositeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns ElementType
	 *     Literal returns ElementType
	 *     CompositeLit returns ElementType
	 *
	 * Constraint:
	 *     (Type=Type LiteralValue=LiteralValue)
	 */
	protected void sequence_CompositeLit_ElementType(ISerializationContext context, ElementType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.ELEMENT_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.ELEMENT_TYPE__TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.LITERAL_TYPE__LITERAL_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.LITERAL_TYPE__LITERAL_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementTypeAccess().getTypeTypeParserRuleCall_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getCompositeLitAccess().getLiteralValueLiteralValueParserRuleCall_1_0(), semanticObject.getLiteralValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns ElementType
	 *
	 * Constraint:
	 *     (Type=Type LiteralValue=LiteralValue PrimaryExprLinha=PrimaryExprLinha)
	 */
	protected void sequence_CompositeLit_ElementType_PrimaryExpr(ISerializationContext context, ElementType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.ELEMENT_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.ELEMENT_TYPE__TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.LITERAL_TYPE__LITERAL_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.LITERAL_TYPE__LITERAL_VALUE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PRIMARY_EXPR_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PRIMARY_EXPR_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementTypeAccess().getTypeTypeParserRuleCall_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getCompositeLitAccess().getLiteralValueLiteralValueParserRuleCall_1_0(), semanticObject.getLiteralValue());
		feeder.accept(grammarAccess.getPrimaryExprAccess().getPrimaryExprLinhaPrimaryExprLinhaParserRuleCall_0_1_0(), semanticObject.getPrimaryExprLinha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns KeyType
	 *     Literal returns KeyType
	 *     CompositeLit returns KeyType
	 *
	 * Constraint:
	 *     (Type=Type ElementType=ElementType LiteralValue=LiteralValue)
	 */
	protected void sequence_CompositeLit_KeyType_MapType(ISerializationContext context, KeyType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.KEY_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.KEY_TYPE__TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.KEY_TYPE__ELEMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.KEY_TYPE__ELEMENT_TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.LITERAL_TYPE__LITERAL_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.LITERAL_TYPE__LITERAL_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKeyTypeAccess().getTypeTypeParserRuleCall_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getMapTypeAccess().getElementTypeElementTypeParserRuleCall_4_0(), semanticObject.getElementType());
		feeder.accept(grammarAccess.getCompositeLitAccess().getLiteralValueLiteralValueParserRuleCall_1_0(), semanticObject.getLiteralValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns KeyType
	 *
	 * Constraint:
	 *     (Type=Type ElementType=ElementType LiteralValue=LiteralValue PrimaryExprLinha=PrimaryExprLinha)
	 */
	protected void sequence_CompositeLit_KeyType_MapType_PrimaryExpr(ISerializationContext context, KeyType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.KEY_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.KEY_TYPE__TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.KEY_TYPE__ELEMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.KEY_TYPE__ELEMENT_TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.LITERAL_TYPE__LITERAL_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.LITERAL_TYPE__LITERAL_VALUE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PRIMARY_EXPR_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PRIMARY_EXPR_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKeyTypeAccess().getTypeTypeParserRuleCall_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getMapTypeAccess().getElementTypeElementTypeParserRuleCall_4_0(), semanticObject.getElementType());
		feeder.accept(grammarAccess.getCompositeLitAccess().getLiteralValueLiteralValueParserRuleCall_1_0(), semanticObject.getLiteralValue());
		feeder.accept(grammarAccess.getPrimaryExprAccess().getPrimaryExprLinhaPrimaryExprLinhaParserRuleCall_0_1_0(), semanticObject.getPrimaryExprLinha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns LiteralType
	 *     Literal returns LiteralType
	 *     CompositeLit returns LiteralType
	 *
	 * Constraint:
	 *     (ArrayType=ArrayType LiteralValue=LiteralValue)
	 */
	protected void sequence_CompositeLit_LiteralType(ISerializationContext context, LiteralType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.LITERAL_TYPE__ARRAY_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.LITERAL_TYPE__ARRAY_TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.LITERAL_TYPE__LITERAL_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.LITERAL_TYPE__LITERAL_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralTypeAccess().getArrayTypeArrayTypeParserRuleCall_1_0(), semanticObject.getArrayType());
		feeder.accept(grammarAccess.getCompositeLitAccess().getLiteralValueLiteralValueParserRuleCall_1_0(), semanticObject.getLiteralValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns LiteralType
	 *
	 * Constraint:
	 *     (ArrayType=ArrayType LiteralValue=LiteralValue PrimaryExprLinha=PrimaryExprLinha)
	 */
	protected void sequence_CompositeLit_LiteralType_PrimaryExpr(ISerializationContext context, LiteralType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.LITERAL_TYPE__ARRAY_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.LITERAL_TYPE__ARRAY_TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.LITERAL_TYPE__LITERAL_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.LITERAL_TYPE__LITERAL_VALUE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PRIMARY_EXPR_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PRIMARY_EXPR_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralTypeAccess().getArrayTypeArrayTypeParserRuleCall_1_0(), semanticObject.getArrayType());
		feeder.accept(grammarAccess.getCompositeLitAccess().getLiteralValueLiteralValueParserRuleCall_1_0(), semanticObject.getLiteralValue());
		feeder.accept(grammarAccess.getPrimaryExprAccess().getPrimaryExprLinhaPrimaryExprLinhaParserRuleCall_0_1_0(), semanticObject.getPrimaryExprLinha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns CompositeLit
	 *
	 * Constraint:
	 *     (LiteralValue=LiteralValue PrimaryExprLinha=PrimaryExprLinha)
	 */
	protected void sequence_CompositeLit_PrimaryExpr(ISerializationContext context, CompositeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns StructType
	 *
	 * Constraint:
	 *     (FieldDecl=FieldDecl+ LiteralValue=LiteralValue PrimaryExprLinha=PrimaryExprLinha)
	 */
	protected void sequence_CompositeLit_PrimaryExpr_StructType(ISerializationContext context, StructType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns StructType
	 *     Literal returns StructType
	 *     CompositeLit returns StructType
	 *
	 * Constraint:
	 *     (FieldDecl=FieldDecl+ LiteralValue=LiteralValue)
	 */
	protected void sequence_CompositeLit_StructType(ISerializationContext context, StructType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns ConstSpec
	 *     TopLevelDecl returns ConstSpec
	 *     ConstDecl returns ConstSpec
	 *     ConstSpec returns ConstSpec
	 *
	 * Constraint:
	 *     ExpressionList=ExpressionList
	 */
	protected void sequence_ConstSpec(ISerializationContext context, ConstSpec semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONST_SPEC__EXPRESSION_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONST_SPEC__EXPRESSION_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstSpecAccess().getExpressionListExpressionListParserRuleCall_1_2_0(), semanticObject.getExpressionList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TopLevelDecl returns Type
	 *
	 * Constraint:
	 *     (
	 *         TypeLit=TypeLit 
	 *         ((ParameterDecl=ParameterDecl? (Result=Result | Signature=Signature)?) | ExpressionList=ExpressionList | ExpressionList=ExpressionList)?
	 *     )
	 */
	protected void sequence_ConstSpec_MethodDecl_ParameterList_Signature_Type_VarSpec(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstDecl returns Type
	 *     ConstSpec returns Type
	 *
	 * Constraint:
	 *     (TypeLit=TypeLit ExpressionList=ExpressionList)
	 */
	protected void sequence_ConstSpec_Type(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.TYPE__TYPE_LIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.TYPE__TYPE_LIT));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONST_SPEC__EXPRESSION_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONST_SPEC__EXPRESSION_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getTypeLitTypeLitParserRuleCall_1_0(), semanticObject.getTypeLit());
		feeder.accept(grammarAccess.getConstSpecAccess().getExpressionListExpressionListParserRuleCall_1_2_0(), semanticObject.getExpressionList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns Type
	 *
	 * Constraint:
	 *     (TypeLit=TypeLit (ExpressionList=ExpressionList | ExpressionList=ExpressionList)?)
	 */
	protected void sequence_ConstSpec_Type_VarSpec(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Conversion returns Conversion
	 *
	 * Constraint:
	 *     Expression=Expression
	 */
	protected void sequence_Conversion(ISerializationContext context, Conversion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns Type
	 *
	 * Constraint:
	 *     (
	 *         TypeLit=TypeLit 
	 *         (
	 *             (ParameterDecl=ParameterDecl? Result=Result? FunctionBody=FunctionBody PrimaryExprLinha=PrimaryExprLinha) | 
	 *             PrimaryExprLinha=PrimaryExprLinha | 
	 *             (Expression=Expression PrimaryExprLinha=PrimaryExprLinha)
	 *         )
	 *     )
	 */
	protected void sequence_Conversion_FunctionLit_ParameterList_PrimaryExpr_Signature_Type(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns Conversion
	 *
	 * Constraint:
	 *     (Expression=Expression PrimaryExprLinha=PrimaryExprLinha)
	 */
	protected void sequence_Conversion_PrimaryExpr(ISerializationContext context, Conversion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Conversion returns Type
	 *
	 * Constraint:
	 *     (TypeLit=TypeLit Expression=Expression)
	 */
	protected void sequence_Conversion_Type(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.TYPE__TYPE_LIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.TYPE__TYPE_LIT));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.TYPE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.TYPE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getTypeLitTypeLitParserRuleCall_1_0(), semanticObject.getTypeLit());
		feeder.accept(grammarAccess.getConversionAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ElementList returns UnaryExpr
	 *
	 * Constraint:
	 *     (PrimaryExpr=PrimaryExpr ExpressionLinha=ExpressionLinha Element=Element KeyedElement=KeyedElement?)
	 */
	protected void sequence_ElementList_Expression_KeyedElement_UnaryExpr(ISerializationContext context, UnaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementList returns KeyedElement
	 *
	 * Constraint:
	 *     (Element=Element KeyedElement=KeyedElement?)
	 */
	protected void sequence_ElementList_KeyedElement(ISerializationContext context, KeyedElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementList returns LiteralValue
	 *
	 * Constraint:
	 *     (ElementList=ElementList Element=Element KeyedElement=KeyedElement?)
	 */
	protected void sequence_ElementList_KeyedElement_LiteralValue(ISerializationContext context, LiteralValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeLit returns ElementType
	 *     ElementType returns ElementType
	 *     SliceType returns ElementType
	 *     ChannelType returns ElementType
	 *     LiteralType returns ElementType
	 *
	 * Constraint:
	 *     Type=Type
	 */
	protected void sequence_ElementType(ISerializationContext context, ElementType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.ELEMENT_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.ELEMENT_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementTypeAccess().getTypeTypeParserRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns UnaryExpr
	 *     TopLevelDecl returns UnaryExpr
	 *     ExpressionList returns UnaryExpr
	 *     VarDecl returns UnaryExpr
	 *     VarSpec returns UnaryExpr
	 *     ShortVarDecl returns UnaryExpr
	 *     Arguments returns UnaryExpr
	 *
	 * Constraint:
	 *     (PrimaryExpr=PrimaryExpr ExpressionLinha=ExpressionLinha Expression=Expression?)
	 */
	protected void sequence_Expression_ExpressionList_UnaryExpr(ISerializationContext context, UnaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KeyedElement returns UnaryExpr
	 *
	 * Constraint:
	 *     (PrimaryExpr=PrimaryExpr ExpressionLinha=ExpressionLinha Element=Element)
	 */
	protected void sequence_Expression_KeyedElement_UnaryExpr(ISerializationContext context, UnaryExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.UNARY_EXPR__PRIMARY_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.UNARY_EXPR__PRIMARY_EXPR));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.UNARY_EXPR__EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.UNARY_EXPR__EXPRESSION_LINHA));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.KEYED_ELEMENT__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.KEYED_ELEMENT__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExprAccess().getPrimaryExprPrimaryExprParserRuleCall_0_0(), semanticObject.getPrimaryExpr());
		feeder.accept(grammarAccess.getExpressionAccess().getExpressionLinhaExpressionLinhaParserRuleCall_1_0(), semanticObject.getExpressionLinha());
		feeder.accept(grammarAccess.getKeyedElementAccess().getElementElementParserRuleCall_1_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns UnaryExpr
	 *
	 * Constraint:
	 *     (PrimaryExpr=PrimaryExpr ExpressionLinha=ExpressionLinha PrimaryExprLinha=PrimaryExprLinha)
	 */
	protected void sequence_Expression_PrimaryExpr_UnaryExpr(ISerializationContext context, UnaryExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.UNARY_EXPR__PRIMARY_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.UNARY_EXPR__PRIMARY_EXPR));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.UNARY_EXPR__EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.UNARY_EXPR__EXPRESSION_LINHA));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PRIMARY_EXPR_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR__PRIMARY_EXPR_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExprAccess().getPrimaryExprPrimaryExprParserRuleCall_0_0(), semanticObject.getPrimaryExpr());
		feeder.accept(grammarAccess.getExpressionAccess().getExpressionLinhaExpressionLinhaParserRuleCall_1_0(), semanticObject.getExpressionLinha());
		feeder.accept(grammarAccess.getPrimaryExprAccess().getPrimaryExprLinhaPrimaryExprLinhaParserRuleCall_0_1_0(), semanticObject.getPrimaryExprLinha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Slice returns UnaryExpr
	 *
	 * Constraint:
	 *     (PrimaryExpr=PrimaryExpr ExpressionLinha=ExpressionLinha Expression=Expression? Expression=Expression)
	 */
	protected void sequence_Expression_Slice_UnaryExpr(ISerializationContext context, UnaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArrayLength returns UnaryExpr
	 *     Operand returns UnaryExpr
	 *     Element returns UnaryExpr
	 *     Key returns UnaryExpr
	 *     Index returns UnaryExpr
	 *     SliceLinha returns UnaryExpr
	 *     Expression returns UnaryExpr
	 *     ExpressionLinha returns UnaryExpr
	 *
	 * Constraint:
	 *     (PrimaryExpr=PrimaryExpr ExpressionLinha=ExpressionLinha)
	 */
	protected void sequence_Expression_UnaryExpr(ISerializationContext context, UnaryExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.UNARY_EXPR__PRIMARY_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.UNARY_EXPR__PRIMARY_EXPR));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.UNARY_EXPR__EXPRESSION_LINHA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.UNARY_EXPR__EXPRESSION_LINHA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExprAccess().getPrimaryExprPrimaryExprParserRuleCall_0_0(), semanticObject.getPrimaryExpr());
		feeder.accept(grammarAccess.getExpressionAccess().getExpressionLinhaExpressionLinhaParserRuleCall_1_0(), semanticObject.getExpressionLinha());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns FunctionLit
	 *     Literal returns FunctionLit
	 *     FunctionLit returns FunctionLit
	 *
	 * Constraint:
	 *     FunctionBody=FunctionBody
	 */
	protected void sequence_FunctionLit(ISerializationContext context, FunctionLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns ParameterList
	 *
	 * Constraint:
	 *     (ParameterDecl=ParameterDecl Result=Result? FunctionBody=FunctionBody PrimaryExprLinha=PrimaryExprLinha)
	 */
	protected void sequence_FunctionLit_ParameterList_PrimaryExpr_Signature(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns ParameterList
	 *     Literal returns ParameterList
	 *     FunctionLit returns ParameterList
	 *
	 * Constraint:
	 *     (ParameterDecl=ParameterDecl Result=Result? FunctionBody=FunctionBody)
	 */
	protected void sequence_FunctionLit_ParameterList_Signature(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns Type
	 *     Literal returns Type
	 *     FunctionLit returns Type
	 *
	 * Constraint:
	 *     (TypeLit=TypeLit ParameterDecl=ParameterDecl? Result=Result? FunctionBody=FunctionBody)
	 */
	protected void sequence_FunctionLit_ParameterList_Signature_Type(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns FunctionLit
	 *
	 * Constraint:
	 *     (FunctionBody=FunctionBody PrimaryExprLinha=PrimaryExprLinha)
	 */
	protected void sequence_FunctionLit_PrimaryExpr(ISerializationContext context, FunctionLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns Signature
	 *
	 * Constraint:
	 *     (Result=Result FunctionBody=FunctionBody PrimaryExprLinha=PrimaryExprLinha)
	 */
	protected void sequence_FunctionLit_PrimaryExpr_Signature(ISerializationContext context, Signature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operand returns Signature
	 *     Literal returns Signature
	 *     FunctionLit returns Signature
	 *
	 * Constraint:
	 *     (Result=Result FunctionBody=FunctionBody)
	 */
	protected void sequence_FunctionLit_Signature(ISerializationContext context, Signature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeLit returns FunctionType
	 *     FunctionType returns FunctionType
	 *
	 * Constraint:
	 *     Signature=Signature
	 */
	protected void sequence_FunctionType(ISerializationContext context, FunctionType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.FUNCTION_TYPE__SIGNATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.FUNCTION_TYPE__SIGNATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionTypeAccess().getSignatureSignatureParserRuleCall_1_0(), semanticObject.getSignature());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Greeting returns Greeting
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Greeting(ISerializationContext context, Greeting semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.GREETING__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.GREETING__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGreetingAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeLit returns InterfaceType
	 *     InterfaceType returns InterfaceType
	 *
	 * Constraint:
	 *     MethodSpec=MethodSpec
	 */
	protected void sequence_InterfaceType(ISerializationContext context, InterfaceType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.INTERFACE_TYPE__METHOD_SPEC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.INTERFACE_TYPE__METHOD_SPEC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInterfaceTypeAccess().getMethodSpecMethodSpecParserRuleCall_2_0_0(), semanticObject.getMethodSpec());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     KeyType returns KeyType
	 *
	 * Constraint:
	 *     Type=Type
	 */
	protected void sequence_KeyType(ISerializationContext context, KeyType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.KEY_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.KEY_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKeyTypeAccess().getTypeTypeParserRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeLit returns KeyType
	 *     MapType returns KeyType
	 *     LiteralType returns KeyType
	 *
	 * Constraint:
	 *     (Type=Type ElementType=ElementType)
	 */
	protected void sequence_KeyType_MapType(ISerializationContext context, KeyType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.KEY_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.KEY_TYPE__TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.KEY_TYPE__ELEMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.KEY_TYPE__ELEMENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKeyTypeAccess().getTypeTypeParserRuleCall_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getMapTypeAccess().getElementTypeElementTypeParserRuleCall_4_0(), semanticObject.getElementType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     KeyedElement returns KeyedElement
	 *
	 * Constraint:
	 *     Element=Element
	 */
	protected void sequence_KeyedElement(ISerializationContext context, KeyedElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.KEYED_ELEMENT__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.KEYED_ELEMENT__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKeyedElementAccess().getElementElementParserRuleCall_1_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     KeyedElement returns LiteralValue
	 *
	 * Constraint:
	 *     (ElementList=ElementList Element=Element)
	 */
	protected void sequence_KeyedElement_LiteralValue(ISerializationContext context, LiteralValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.LITERAL_VALUE__ELEMENT_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.LITERAL_VALUE__ELEMENT_LIST));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.KEYED_ELEMENT__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.KEYED_ELEMENT__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralValueAccess().getElementListElementListParserRuleCall_1_0_0(), semanticObject.getElementList());
		feeder.accept(grammarAccess.getKeyedElementAccess().getElementElementParserRuleCall_1_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LiteralType returns LiteralType
	 *
	 * Constraint:
	 *     ArrayType=ArrayType
	 */
	protected void sequence_LiteralType(ISerializationContext context, LiteralType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.LITERAL_TYPE__ARRAY_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.LITERAL_TYPE__ARRAY_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralTypeAccess().getArrayTypeArrayTypeParserRuleCall_1_0(), semanticObject.getArrayType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LiteralValue returns LiteralValue
	 *     Element returns LiteralValue
	 *     Key returns LiteralValue
	 *
	 * Constraint:
	 *     ElementList=ElementList
	 */
	protected void sequence_LiteralValue(ISerializationContext context, LiteralValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.LITERAL_VALUE__ELEMENT_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.LITERAL_VALUE__ELEMENT_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralValueAccess().getElementListElementListParserRuleCall_1_0_0(), semanticObject.getElementList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TopLevelDecl returns MethodDecl
	 *     MethodDecl returns MethodDecl
	 *
	 * Constraint:
	 *     Signature=Signature
	 */
	protected void sequence_MethodDecl(ISerializationContext context, MethodDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodDecl returns ParameterList
	 *
	 * Constraint:
	 *     (ParameterDecl=ParameterDecl Signature=Signature)
	 */
	protected void sequence_MethodDecl_ParameterList(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TopLevelDecl returns ParameterList
	 *
	 * Constraint:
	 *     (ParameterDecl=ParameterDecl (Result=Result | Signature=Signature)?)
	 */
	protected void sequence_MethodDecl_ParameterList_Signature(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodDecl returns Type
	 *
	 * Constraint:
	 *     (TypeLit=TypeLit ParameterDecl=ParameterDecl? Signature=Signature)
	 */
	protected void sequence_MethodDecl_ParameterList_Type(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     greetings+=Greeting+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Result returns ParameterList
	 *     Parameters returns ParameterList
	 *     ParameterList returns ParameterList
	 *     Receiver returns ParameterList
	 *
	 * Constraint:
	 *     ParameterDecl=ParameterDecl
	 */
	protected void sequence_ParameterList(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Signature returns ParameterList
	 *     MethodSpec returns ParameterList
	 *     FunctionDecl returns ParameterList
	 *
	 * Constraint:
	 *     (ParameterDecl=ParameterDecl Result=Result?)
	 */
	protected void sequence_ParameterList_Signature(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Signature returns Type
	 *     MethodSpec returns Type
	 *     FunctionDecl returns Type
	 *
	 * Constraint:
	 *     (TypeLit=TypeLit ParameterDecl=ParameterDecl? Result=Result?)
	 */
	protected void sequence_ParameterList_Signature_Type(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Result returns Type
	 *     Parameters returns Type
	 *     ParameterList returns Type
	 *     Receiver returns Type
	 *
	 * Constraint:
	 *     (TypeLit=TypeLit ParameterDecl=ParameterDecl?)
	 */
	protected void sequence_ParameterList_Type(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpr returns PrimaryExpr
	 *
	 * Constraint:
	 *     (PrimaryExprLinha=PrimaryExprLinha | PrimaryExprLinha=PrimaryExprLinha)
	 */
	protected void sequence_PrimaryExpr(ISerializationContext context, PrimaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Signature returns Signature
	 *     MethodSpec returns Signature
	 *     TopLevelDecl returns Signature
	 *     FunctionDecl returns Signature
	 *
	 * Constraint:
	 *     Result=Result
	 */
	protected void sequence_Signature(ISerializationContext context, Signature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Slice returns Slice
	 *
	 * Constraint:
	 *     (Expression=Expression? Expression=Expression)
	 */
	protected void sequence_Slice(ISerializationContext context, Slice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeLit returns StructType
	 *     StructType returns StructType
	 *     LiteralType returns StructType
	 *
	 * Constraint:
	 *     FieldDecl=FieldDecl+
	 */
	protected void sequence_StructType(ISerializationContext context, StructType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *     FieldDecl returns Type
	 *     ParameterDecl returns Type
	 *     TypeDecl returns Type
	 *     TypeSpec returns Type
	 *     AliasDecl returns Type
	 *     TypeDef returns Type
	 *     TypeAssertion returns Type
	 *     MethodExpr returns Type
	 *     ReceiverType returns Type
	 *
	 * Constraint:
	 *     TypeLit=TypeLit
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.TYPE__TYPE_LIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.TYPE__TYPE_LIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getTypeLitTypeLitParserRuleCall_1_0(), semanticObject.getTypeLit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarDecl returns Type
	 *     VarSpec returns Type
	 *
	 * Constraint:
	 *     (TypeLit=TypeLit ExpressionList=ExpressionList?)
	 */
	protected void sequence_Type_VarSpec(ISerializationContext context, Type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnaryExpr returns UnaryExpr
	 *
	 * Constraint:
	 *     PrimaryExpr=PrimaryExpr
	 */
	protected void sequence_UnaryExpr(ISerializationContext context, UnaryExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.UNARY_EXPR__PRIMARY_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.UNARY_EXPR__PRIMARY_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExprAccess().getPrimaryExprPrimaryExprParserRuleCall_0_0(), semanticObject.getPrimaryExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns VarSpec
	 *     TopLevelDecl returns VarSpec
	 *     VarDecl returns VarSpec
	 *     VarSpec returns VarSpec
	 *
	 * Constraint:
	 *     ExpressionList=ExpressionList
	 */
	protected void sequence_VarSpec(ISerializationContext context, VarSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
